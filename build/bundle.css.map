{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "..\\..\\Spinner.svelte",
    "..\\..\\Search.svelte",
    "..\\..\\Particles.svelte",
    "..\\..\\Tree.svelte"
  ],
  "sourcesContent": [
    "<style>\r\n  .spin-wrap {\r\n    display: grid;\r\n    place-content: center;\r\n    text-align: center;\r\n    overflow: hidden;\r\n    /* font-size: 200%; */\r\n  }\r\n\r\n  .spin::after {\r\n    display: inline-block;\r\n    content: \"~\";\r\n    /* alt times 0.18s */\r\n    animation: spin 0.4s linear infinite alternate;\r\n  }\r\n\r\n  @keyframes spin {\r\n    0% {\r\n      /* content: \"|\"; */\r\n      /* transform: rotate(0); */\r\n    }\r\n    25% {\r\n      /* content: \"\\\\\"; */\r\n      content: \"*\";\r\n      /* transform: skewX(100deg); */\r\n      /* transform: rotate(90deg); */\r\n    }\r\n    50% {\r\n      /* content: \"-\"; */\r\n      content: \"x\";\r\n      /* transform: skewX(200deg); */\r\n      /* transform: rotate(180deg); */\r\n    }\r\n    75% {\r\n      /* content: \"/\"; */\r\n      content: \"+\";\r\n      /* transform: skewX(100deg); */\r\n      /* transform: rotate(270deg); */\r\n    }\r\n    100% {\r\n      /* content: \"|\"; */\r\n      content: \"-\";\r\n      /* transform: skewX(360deg); */\r\n      /* transform: rotate(360deg); */\r\n    }\r\n  }\r\n</style>\r\n\r\n<br />\r\n<div class=\"spin-wrap\">\r\n  <div>\r\n    loading . . .\r\n    <span class=\"spin\" />\r\n  </div>\r\n</div>\r\n",
    "<script>\r\n  import { onMount } from \"svelte\";\r\n\r\n  onMount(async () => {\r\n    // on Search component load, set focus on search bar\r\n    document.querySelector(\".query\").focus();\r\n\r\n    // console.log(document.querySelector(\".search-wrap\"));\r\n  });\r\n\r\n  // import { createEventDispatcher } from \"svelte\";\r\n  // const dispatch = createEventDispatcher();\r\n  // const func = () => dispatch(\"eventname\", var/ref);\r\n\r\n  // query is 2-way bound between Search and Tree\r\n  // query is textContent\r\n  export let query;\r\n\r\n  // tries to stop select all bug\r\n  let cntrlDown = false;\r\n\r\n  // #cancel mouse-selection of query text\r\n  const queryMousedown = e => {\r\n    e.preventDefault();\r\n  };\r\n\r\n  // does this make no sense/ functionalise other stuff\r\n  // const toggleCntrl = (e) => e.key === 'Control' : cntrlDown = !cntrlDown\r\n\r\n  // watch from control key\r\n  const queryKeyup = e => {\r\n    if (e.key === \"Control\") {\r\n      // toggle global var\r\n      cntrlDown = false;\r\n    }\r\n  };\r\n\r\n  // #cancel special keys\r\n  const queryKeydown = e => {\r\n    // console.log(e.key);\r\n    if (e.key === \"Control\") {\r\n      // toggle global var\r\n      cntrlDown = true;\r\n    }\r\n\r\n    if (\r\n      e.key === \"Enter\" ||\r\n      e.key === \"Control\" ||\r\n      e.key === \"ArrowLeft\" ||\r\n      e.key === \"ArrowRight\" ||\r\n      e.key === \"Delete\" ||\r\n      (e.key === \"Backspace\" && e.target.textContent.length === 1) ||\r\n      (cntrlDown &&\r\n        (e.key === \"a\" ||\r\n          e.key === \"A\" ||\r\n          e.key === \"Delete\" ||\r\n          e.key === \"Backspace\" ||\r\n          e.key === \"v\" ||\r\n          e.key === \"V\"))\r\n    ) {\r\n      e.preventDefault(); // will stop event bubbling --> stops key being pressed\r\n    }\r\n  };\r\n\r\n  // clicking on the body (not any specific elm could call positionCursor?)\r\n  // how do websites set the default mouse/focus place of a website?\r\n\r\n  // from https://www.geeksforgeeks.org/how-to-set-cursor-position-in-content-editable-element-using-javascript/\r\n  // warning: setting 'pointer-events' or 'user-select' to none undermines this function\r\n  const positionCursor = () => {\r\n    // relevant text-element\r\n    const tag = document.querySelector(\".query\");\r\n\r\n    if (tag.textContent.length !== 0) {\r\n      // Creates range object\r\n      const setpos = document.createRange();\r\n      // Creates object for selection\r\n      const set = window.getSelection();\r\n      // Set start position of range\r\n      setpos.setStart(tag.childNodes[0], tag.textContent.length);\r\n      // Collapse range within its boundary points\r\n      // Returns boolean\r\n      setpos.collapse(true);\r\n      // Remove all ranges set\r\n      set.removeAllRanges();\r\n      // Add range with respect to range object\r\n      set.addRange(setpos);\r\n      // Set cursor on focus\r\n      tag.focus();\r\n    } else {\r\n      console.log(\"error, text length =\", tag.textContent.length);\r\n      // throw `err: ${tag.textContent.length}`;\r\n    }\r\n  };\r\n</script>\r\n\r\n<style>\r\n  .omninav {\r\n    display: grid;\r\n    place-items: center;\r\n    background-color: var(--bg-color);\r\n    text-align: left;\r\n    width: 100%;\r\n    padding-left: 2rem;\r\n    padding-right: 2rem;\r\n  }\r\n\r\n  .search {\r\n    color: var(--primary-color);\r\n    display: inline;\r\n  }\r\n\r\n  .search-wrap {\r\n    background-color: rgba(0, 0, 0, 0.69);\r\n    width: 100%;\r\n    /* approx width of .tree (will change with string lengths tho smh) */\r\n    max-width: 28.5rem;\r\n    margin-top: 2rem;\r\n    margin-bottom: 2rem;\r\n    padding-left: 0.2rem;\r\n    padding-right: 0.2rem;\r\n    outline: 1px solid white;\r\n    cursor: text;\r\n  }\r\n\r\n  .query {\r\n    outline: none;\r\n    caret-color: transparent;\r\n    /* vertical-align: middle; */\r\n  }\r\n\r\n  .query::before {\r\n    content: \"$_:\";\r\n    display: inline;\r\n    color: var(--secondary-color);\r\n    padding-left: 0.15rem;\r\n  }\r\n\r\n  .query::after {\r\n    content: \"\";\r\n    display: inline-block;\r\n    width: 0.8rem;\r\n    height: 1.7rem;\r\n    margin-bottom: 0.15rem;\r\n    margin-left: 0.15rem;\r\n    background-color: var(--primary-color);\r\n    vertical-align: middle;\r\n    animation: blink 1.6s ease-in-out infinite;\r\n  }\r\n\r\n  @keyframes blink {\r\n    0% {\r\n      opacity: 1;\r\n    }\r\n    20% {\r\n      opacity: 0.4;\r\n    }\r\n    40% {\r\n      opacity: 0;\r\n    }\r\n    60% {\r\n      opacity: 0.4;\r\n    }\r\n    80% {\r\n      opacity: 0.8;\r\n    }\r\n    100% {\r\n      opacity: 1;\r\n    }\r\n  }\r\n</style>\r\n\r\n<div class=\"omninav\" on:click={positionCursor}>\r\n  <div class=\"search-wrap ow\">\r\n    <div class=\"search\" on:click={positionCursor}>\r\n      <span\r\n        class=\"query\"\r\n        contenteditable=\"true\"\r\n        spellcheck=\"false\"\r\n        bind:textContent={query}\r\n        on:click={positionCursor}\r\n        on:keydown={queryKeydown}\r\n        on:keyup={queryKeyup}\r\n        on:mousedown={queryMousedown} />\r\n    </div>\r\n  </div>\r\n</div>\r\n\r\n<!--  // trick to join onMount and $:label's powers\r\n  // let mounted = false;\r\n  // runs after component is loaded into the DOM - could put like, a lot of code in here\r\n  // onMount(async () => {\r\n  //   mounted = true;\r\n  // });\r\n\r\n  // catch select all, press a key bug that overrides the first whitespace character (needed for clickable width)\r\n  // $: if (query && query.charAt(0) !== \"Â \") {\r\n  //   console.log(`'${query}'`);\r\n  //   query = \" \" + query;\r\n  //   console.log(`'${query.charAt(0)}'`);\r\n  // }\r\n   -->\r\n\r\n<!-- on:keypress={queryKeypress} -->\r\n<!-- on:keypress={console.log('keypress')} -->\r\n<!-- &nbsp; -->\r\n\r\n<!--\r\n  // count valid keypresses and restricts length\r\n  // only runs if key is not a special key\r\n  // forces search to remain single-line\r\n  const queryKeypress = e => {\r\n  // 21chars is max at 320px (i5)\r\n  // assume ~25-30% of clientWidth is not .query\r\n  // assume font-size: ~1rem\r\n  // 320 * 0.7 = 224\r\n  // 224 / 21 = ~10px per char\r\n  // use an equation between char size and omnibar width\r\n  let max = Math.floor(\r\n    (document.querySelector(\".navbar\").clientWidth * 0.666) / 10\r\n  );\r\n  console.log(max);\r\n  if (e.target.textContent.length > max) {\r\n    e.preventDefault();\r\n  }\r\n  };\r\n-->\r\n\r\n<!-- \r\n    // also an option from https://stackoverflow.com/a/7445389\r\n    // function SetEnd(txt) {\r\n      if (txt.createTextRange) {\r\n       //IE\r\n       var FieldRange = txt.createTextRange();\r\n       FieldRange.moveStart('character', txt.value.length);\r\n       FieldRange.collapse();\r\n       FieldRange.select();\r\n       }\r\n      else {\r\n       //Firefox and Opera\r\n       txt.focus();\r\n       var length = txt.value.length;\r\n       txt.setSelectionRange(length, length);\r\n      }\r\n    }\r\n  -->\r\n",
    "<script>\r\n  /*  Particles in p5.js code from https://www.youtube.com/watch?v=H-9jCNhLe-Q\r\n      Modified by using import and a module instance pattern\r\n      Required re-writing Particle class into Object prototype syntax\r\n      Required modifying many 'this.' into 'sketch.' (but not all)\r\n  */\r\n  import p5 from \"../public/p5.min\";\r\n  import { onMount } from \"svelte\";\r\n\r\n  onMount(async () => {\r\n    const s = sketch => {\r\n      const particles = [];\r\n\r\n      let parentWidth;\r\n      let parentHeight;\r\n\r\n      sketch.setup = () => {\r\n        // get parent width / height\r\n        parentWidth = document.querySelector(\"#p5-wrap\").offsetWidth;\r\n        parentHeight = document.querySelector(\"#p5-wrap\").offsetHeight;\r\n\r\n        let canvas = sketch.createCanvas(parentWidth, parentHeight);\r\n\r\n        canvas.parent(\"p5-wrap\");\r\n\r\n        const particlesLength = Math.min(Math.floor(parentWidth / 100), 100);\r\n        for (let i = 0; i < particlesLength; i++) {\r\n          // let p = new sketch.Particle();\r\n          // console.log(typeof p);\r\n          particles.push(new sketch.Particle());\r\n        }\r\n        // console.log(particles[0].toString());\r\n      };\r\n\r\n      sketch.draw = () => {\r\n        sketch.clear();\r\n        particles.forEach((particle, idx) => {\r\n          particle.update();\r\n          particle.draw();\r\n          particle.checkParticles(particles.slice(idx));\r\n        });\r\n      };\r\n\r\n      sketch.Particle = function() {\r\n        this.pos = sketch.createVector(\r\n          sketch.random(sketch.width),\r\n          sketch.random(sketch.height)\r\n        );\r\n        this.vel = sketch.createVector(\r\n          sketch.random(-2, 2),\r\n          sketch.random(-2, 2)\r\n        );\r\n        this.size = 25;\r\n\r\n        // console.log(this.toString());\r\n      };\r\n\r\n      sketch.Particle.prototype.update = function() {\r\n        this.pos.add(this.vel);\r\n        this.edges();\r\n      };\r\n\r\n      sketch.Particle.prototype.draw = function() {\r\n        // console.log(sketch.addClass(\"bg-blur\"));\r\n        sketch.noStroke();\r\n        sketch.fill(\"rgba(255, 255, 255, 0.5)\");\r\n        sketch.circle(this.pos.x, this.pos.y, this.size * 2);\r\n      };\r\n\r\n      sketch.Particle.prototype.edges = function() {\r\n        if (this.pos.x < 0 || this.pos.x > sketch.width) {\r\n          this.vel.x *= -1;\r\n        }\r\n\r\n        if (this.pos.y < 0 || this.pos.y > sketch.height) {\r\n          this.vel.y *= -1;\r\n        }\r\n\r\n        // \t\tif(this.pos.x > width) {\r\n        // \t\t\tthis.pos.x = 0;\r\n        // \t\t}\r\n\r\n        // \t\tif(this.pos.y > height) {\r\n        // \t\t\tthis.pos.y = 0;\r\n        // \t\t}\r\n      };\r\n\r\n      sketch.Particle.prototype.checkParticles = function(particles) {\r\n        particles.forEach(particle => {\r\n          const d = sketch.dist(\r\n            this.pos.x,\r\n            this.pos.y,\r\n            particle.pos.x,\r\n            particle.pos.y\r\n          );\r\n          if (d < 120) {\r\n            const alpha = sketch.map(d, 0, 120, 0, 0.25);\r\n            sketch.stroke(`rgba(255, 255, 255, ${alpha})`);\r\n            sketch.line(this.pos.x, this.pos.y, particle.pos.x, particle.pos.y);\r\n          }\r\n        });\r\n      };\r\n    };\r\n    // instance a p5 module\r\n    // @param s = the instances 'seed' (??)\r\n    // https://github.com/processing/p5.js/wiki/Global-and-instance-mode\r\n    let myp5 = new p5(s);\r\n  });\r\n</script>\r\n\r\n<style>\r\n  #p5-wrap {\r\n    position: fixed;\r\n    top: 0;\r\n    left: 0;\r\n    z-index: -2;\r\n    height: 100vh;\r\n    width: 100%;\r\n  }\r\n\r\n  /* .bg-blur {\r\n    background-color: red;\r\n    color: rgb(255, 238, 0);\r\n  } */\r\n</style>\r\n\r\n<div id=\"p5-wrap\" />\r\n",
    "<script>\r\n  // import flatten from \"flat\";\r\n  import { onMount } from \"svelte\";\r\n\r\n  // add to videos: tidbits, PAVEMENT_2017_AH18, ...\r\n  // only use lower-case to sync with lowercase-sanitised input\r\n\r\n  // get site tree (pre-parsed)\r\n  import tree from \"../public/tree.json\";\r\n\r\n  // explicitly make this an empty string so the label function\r\n  // query.length doesn't error out over an undefined query\r\n  export let query = \"\";\r\n\r\n  // filtered arrays of DOM nodes used for wiping styles\r\n  let branches, subbranches;\r\n\r\n  // global for key navigation of tree\r\n  let currentbranch;\r\n\r\n  // runs after component is loaded into the DOM - could put like, a lot of code in here\r\n  // 1. functionalise code\r\n  // 2. call functions from onMount (but not event listeners or globals etc)\r\n  onMount(async () => {\r\n    // build DOM grid\r\n    await createGrid(tree);\r\n\r\n    // build tree onto DOM grid\r\n    await createTree(tree);\r\n\r\n    // get all non-empty branches\r\n    branches = Array.from(document.querySelectorAll(\".c1\")).filter(\r\n      b => b.textContent\r\n    );\r\n\r\n    // get all non-empty subbranches (now unneeded due to better mapping)\r\n    subbranches = Array.from(document.querySelectorAll(\".c2\")).filter(\r\n      sb => sb.textContent\r\n    );\r\n  });\r\n\r\n  // start matching from 1 meaningful char (accounts for whitespace)\r\n  // is there another thing to label-listen for...\r\n  $: if (query.length > 2) {\r\n    // sanitise input for branch matching\r\n    query = query.substring(1).toLowerCase();\r\n\r\n    // loop through branches\r\n    for (const b of tree) {\r\n      // if branch includes query, style branch\r\n      if (b[0].includes(query)) {\r\n        if (typeof b[1] === \"object\") {\r\n          styleBranch(b[2], \"Bottom\", 1);\r\n        } else {\r\n          styleBranch(b[2], \"\", 1);\r\n        }\r\n      }\r\n\r\n      // if parent branch\r\n      if (typeof b[1] === \"object\") {\r\n        // if query match, set this flag to style preceding subbranches\r\n        let crawl = false;\r\n\r\n        // reverse-loop through parents subbranches\r\n        for (let i = b[1].length - 1; i >= 0; i--) {\r\n          // if subbranch display text includes query\r\n          if (b[1][i][0].includes(query)) {\r\n            // set query match subbranch to currentbranch\r\n            currentbranch = b[1][i][2];\r\n\r\n            if (i !== 0) {\r\n              // query-match is a non-first-subbranch\r\n\r\n              // set flag to style in-between subbranches\r\n              crawl = true;\r\n\r\n              setTimeout(() => {\r\n                styleBranch(b[1][i][2], \"Left\", 1);\r\n              }, 300);\r\n            } else {\r\n              // query match is first-subbranch\r\n              setTimeout(() => {\r\n                styleBranch(b[1][i][2], \"Bottom\", 1);\r\n                styleBranch(b[1][i][2].previousElementSibling, \"Bottom\", 0.3);\r\n              }, 300);\r\n            }\r\n            setTimeout(() => {\r\n              styleBranch(b[1][i][2], \"Bottom\", 1);\r\n            }, 300);\r\n          } else if (crawl) {\r\n            // then previous loop query matched a non-first-subbranch above sb[i]\r\n            if (i === 0) {\r\n              // style first-subbranch and parent branch\r\n              // styleBranch(b[1][i][2], \"\", 0.3);\r\n              styleBranch(b[1][i][2].previousElementSibling, \"Bottom\", 0.3);\r\n            } else {\r\n              // style preceding non-first-subbranch\r\n              setTimeout(() => {\r\n                styleBranch(b[1][i][2], \"Left\", 0.3);\r\n              }, 50);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    // try design out these style-canceling loops by using class toggles?\r\n    // end of subbranches loop\r\n  } else if (branches && subbranches) {\r\n    // query is 0 or 1 characters --> reset all styles\r\n    // [functionalise this code]\r\n    for (const branch of branches) {\r\n      // remove branch opacity highlight and border\r\n      styleBranch(branch, \"\", 0.1);\r\n      // reset exact matched branch color\r\n      branch.style.color = \"#fff\";\r\n    }\r\n    for (const subbranch of subbranches) {\r\n      // remove subbranch opacity highlight and border\r\n      styleBranch(subbranch, \"\", 0.1);\r\n      // reset exact matched subbranch color\r\n      if (subbranch.firstElementChild) {\r\n        subbranch.firstElementChild.style.color = \"#fff\";\r\n      }\r\n    }\r\n  }\r\n\r\n  // build DOM tree from a nested array\r\n  const createTree = array => {\r\n    // counters for columns and rows\r\n    // counter var is unnecessary until sub-sub-branches occur\r\n    // let c = 1;\r\n    let r = 1;\r\n\r\n    for (const branch of array) {\r\n      // save branch DOM node\r\n      const b = document.querySelector(`.c1.r${r}`);\r\n\r\n      // add ref to branch DOM node back into tree.json\r\n      branch.push(b);\r\n\r\n      // detect parent branch\r\n      if (typeof branch[1] == \"object\") {\r\n        // add parent branch name\r\n        b.textContent = branch[0];\r\n\r\n        // set to column 2 for subbranches loop\r\n        // c = 2;\r\n\r\n        for (const subbranch of branch[1]) {\r\n          // console.log(\"key\", subbranch[0]);\r\n          // console.log(\"value\", subbranch[1]);\r\n\r\n          // save subbranch DOM node\r\n          const sb = document.querySelector(`.c2.r${r}`);\r\n\r\n          // add ref to subbranch DOM node back into tree.json\r\n          subbranch.push(sb);\r\n\r\n          // console.log(subbranch);\r\n\r\n          // detect if subbranch display value is text or a link and assign\r\n          sb.innerHTML = detectLink(subbranch);\r\n\r\n          // move down to next subbranch\r\n          r++;\r\n        }\r\n\r\n        // move one up\r\n        r--;\r\n\r\n        // add margin-bump to last subbranch of current branch\r\n        document.querySelector(`.c2.r${r}`).style.marginBottom = \"1rem\";\r\n\r\n        // experiment: change the width of the text to fit-content?\r\n        // could shrink the borderline to just the width of the text\r\n        // it worked! should this just be generally applied? can copypasta\r\n        // the @supports CSS from heal_thy\r\n        // document.querySelector(`.c2.r${r}`).style.width = \"fit-content\";\r\n        // reset for new branch\r\n        // c = 1;\r\n        r++;\r\n      } else {\r\n        document.querySelector(`.c1.r${r}`).textContent = branch[0];\r\n        // reset for new branch\r\n        // c = 1;\r\n        r++;\r\n      }\r\n    }\r\n    // r - 1 = total grid rows --> save to global\r\n    // numrows = r - 1;\r\n    console.log(tree);\r\n  };\r\n\r\n  // called from query listener to dynamically style the tree\r\n  const styleBranch = (branch, edge, opacity) => {\r\n    let border;\r\n    // if edge is truthy, branch is being selected\r\n    // set border edge value to primary green var\r\n    if (edge) {\r\n      border = \"2px solid var(--primary-color)\";\r\n    } else {\r\n      // edge is falsy, branch is being de-selected\r\n      // set border value to transparent\r\n      border = \"2px solid rgba(94, 255, 0, 0)\";\r\n    }\r\n\r\n    // construct object from params as JSON\r\n    let styleObj = JSON.parse(\r\n      `{ \"opacity\": ${opacity}, \"border${edge}\": \"${border}\" }`\r\n    );\r\n    // add styles (without overwriting)\r\n    Object.assign(branch.style, styleObj);\r\n  };\r\n\r\n  // returns a key-value pair as DOM string\r\n  // called from createTree to check if link or text\r\n  const detectLink = sb => {\r\n    if (sb[1].substring(0, 4) === \"http\") {\r\n      // set display value to a link href and use the key as the display text\r\n      // conditionalise if a external or local (ie to another page of the same website) link\r\n      // so that target=\"_blank\" only applies to externals? or just remove it?\r\n\r\n      // could this be the place to insert the bind:textContents?\r\n      // bind:this={${sb.push(e.target)}}\r\n      return `<a target=\"_blank\" href=\"${sb[1]}\">${sb[0]}</a>`;\r\n    } else {\r\n      // set display value to value\r\n      return `<p>${sb[1]}</p>`;\r\n    }\r\n  };\r\n  // on:mouseover={e.target.style.color='var(--primary-color)!important'}\r\n\r\n  // (assume) on first key detection current = .c1.r1\r\n  // (unless) a query-match has been made\r\n  // (or) multiple query-matches have been made\r\n\r\n  // handle tree key navigation\r\n  document.addEventListener(\"keydown\", e => {\r\n    if (!currentbranch) {\r\n      // no current query-match, set current to .c1.r1\r\n      currentbranch = branches[0];\r\n    }\r\n    // theoretically could now use DOM classList to navigate...\r\n    // eventually, will need to turn entire json tree into arrays sigh\r\n    // otherwise dealing with c1 branches is going to be a huge pain\r\n    switch (e.key) {\r\n      case \"ArrowLeft\":\r\n        console.log(e.key);\r\n        styleBranch(currentbranch, \"\", \"1\");\r\n        break;\r\n      case \"ArrowRight\":\r\n        console.log(e.key);\r\n        break;\r\n      case \"ArrowUp\":\r\n        console.log(e.key);\r\n        break;\r\n      case \"ArrowDown\":\r\n        console.log(e.key);\r\n        break;\r\n    }\r\n  });\r\n\r\n  // build DOM grid from a nested array\r\n  const createGrid = array => {\r\n    const grid = document.querySelector(\".tree\");\r\n    for (let i = 1; i <= array.flat().length; i++) {\r\n      let a = document.createElement(\"div\");\r\n      let b = document.createElement(\"div\");\r\n      a.className = `c1 r${i}`;\r\n      b.className = `c2 r${i}`;\r\n      grid.append(a, b);\r\n    }\r\n  };\r\n</script>\r\n\r\n<style>\r\n  .tree {\r\n    grid-gap: 0;\r\n    grid-template-columns: repeat(2, min-content);\r\n    background-color: var(--bg-color);\r\n    padding: 0 0.5rem;\r\n  }\r\n  /* moved tree branch styles from here into global.css to avoid getting compiled out */\r\n</style>\r\n\r\n<div class=\"wrap\">\r\n  <div class=\"tree grid-2\" />\r\n  <!-- generated by buildTree() -->\r\n</div>\r\n\r\n<!-- /*\r\n    are the css styles for tree branches getting compiled out?\r\n    now that the DOM branches are generated, style's arent\r\n    getting applied from the svelte css block...\r\n\r\n    how can i time the activation or delivery of these css rules?\r\n    bung em into global.css? good test of compiled out theory\r\n\r\n    result: it worked, moving to global returned functionality\r\n  */ -->\r\n\r\n<!-- <div class=\"c1 r1\" />\r\n    <div class=\"c2 r1\" />\r\n    <div class=\"c1 r2\" />\r\n    <div class=\"c2 r2\" />\r\n    <div class=\"c1 r3\" />\r\n    <div class=\"c2 r3\" />\r\n    <div class=\"c1 r4\" />\r\n    <div class=\"c2 r4\" />\r\n    <div class=\"c1 r5\" />\r\n    <div class=\"c2 r5\" />\r\n    <div class=\"c1 r6\" />\r\n    <div class=\"c2 r6\" />\r\n    <div class=\"c1 r7\" />\r\n    <div class=\"c2 r7\" />\r\n    <div class=\"c1 r8\" />\r\n    <div class=\"c2 r8\" />\r\n    <div class=\"c1 r9\" />\r\n    <div class=\"c2 r9\" />\r\n    <div class=\"c1 r10\" />\r\n    <div class=\"c2 r10\" /> -->\r\n\r\n<!-- ------------------------------------------------------------- -->\r\n<!-- CODE I HAD TO map(tree.json <==> DOM grid) THAT WERE 2MESSY:  -->\r\n<!-- ------------------------------------------------------------- -->\r\n<!-- \r\n    { can now access tree sub-structures (via indexes) and\r\n      sub node position in tree and DOM with one referent }\r\n\r\n    // less complex parentbranch list (has no blanks to filter)\r\n    // let parentbranches = document.querySelectorAll(\".pb\");\r\n\r\n      // for (const branch of branches) {\r\n      // if the branch-text includes the query as a whole string, style branch\r\n      // if (branch.textContent.includes(query)) {\r\n      //   styleBranch(branch, \"\", 1);\r\n\r\n        // highlight exact match\r\n        // if (branch.textContent === query) {\r\n        //   branch.style.color = \"var(--primary-color)\";\r\n        // }\r\n    //   }\r\n    // }\r\n\r\n    /*\r\n      1.  detect parent branches\r\n      2.  loop through each set of subbranches\r\n      3.  use breaks/continues/returns (applies to all my loops tbh)\r\n    */\r\n    // highlight exact match\r\n    // if (subbranch.textContent === query) {\r\n    //   subbranch.firstElementChild.style.color = \"var(--primary-color)\";\r\n    // }\r\n\r\n    // if (subbranch.style.marginBottom === \"1rem\") {\r\n    //   // console.log(\"last subbranch:\", subbranch);\r\n    //   styleBranch(subbranch, \"Bottom\", 0.3);\r\n    // }\r\n\r\n    // add styling to not-first-not-query-target-subbranch\r\n    //   styleBranch(subbranches[ii], \"Left\", 0.3);\r\n    // } else {\r\n    // add styling to subbranch target\r\n    //   styleBranch(subbranches[ii], \"Left\", 1);\r\n    // }\r\n\r\n    // mutable copy of index to crawl up subbranches\r\n    // let ii = i;\r\n    // let crawl = false;\r\n    // only run subbranch crawl if not currently on first subbranch\r\n    // if (!subbranch.previousElementSibling.textContent) {\r\n    // check if target subbranch = last subbranch\r\n    // (dupe condition in createTree ðŸ¤”ðŸ¤”ðŸ¤”)\r\n\r\n    // while the cell to my left is empty, iterate up subbranches\r\n    // do {\r\n    // if crawl is false then this is the first do loop iteration\r\n    // if (crawl) {\r\n      // test: box off branches? detect last subbranch\r\n\r\n    // console.log(ii);\r\n    // iterate up one subbranch\r\n    // ii--;\r\n\r\n    // set flag to true\r\n    // crawl = true;\r\n\r\n    // if textContent, the previous sibling is the parent branch\r\n    // } while (!subbranches[ii].previousElementSibling.textContent);\r\n    // }\r\n    // else {\r\n    //   console.log(\"skipped while loop\r\n    target sb is first sb\");\r\n    // }\r\n\r\n    // check if ii is on first subbranch\r\n    // either by while loop iteration or\r\n    // if first subbranch = query target\r\n\r\n    // if (subbranches[ii].previousElementSibling.textContent) {\r\n      \r\n    //   // add styling to first subbranch\r\n    //   if (crawl) {\r\n    //     // then first subbranch is not the query target\r\n    //     styleBranch(subbranches[ii], \"Left\", 0.3);\r\n    //     // test: box off subbranches?\r\n    //     // styleBranch(subbranches[ii], \"Top\", 0.3);\r\n    //   } else {\r\n    //     // crawl was skipped and first subbranch is query target\r\n    //     styleBranch(subbranch, \"Left\", 1);\r\n    //   }\r\n    //   // style parent branch\r\n    //   styleBranch(subbranches[ii].previousElementSibling, \"Bottom\", 0.3);\r\n    // }\r\n    // }\r\n    // }\r\n-->\r\n\r\n<!-- ------------------------------------------------------------- -->\r\n<!-- IDEAS I HAD TO map(tree.json <==> DOM grid) THAT WERE 2MESSY: -->\r\n<!-- ------------------------------------------------------------- -->\r\n<!-- \r\n  // how to build a mapping from json data to DOM? surely Svelte has a fix\r\n  // what if during createTree I create a bind:value/textContent to a specific\r\n  // variable, per each grid-item?\r\n\r\n  /* flow:\r\n      1. load json tree\r\n      2. (calculate size of DOM grid from JSON tree?)\r\n      3. createTree populates DOM tree\r\n      4. each b/sb has a bind:textContent\r\n      5. these bound values are stored in a mapping\r\n      6. that mapping can be used for query-matching\r\n      6. could values be bound directly back to the tree??\r\n  */\r\n\r\n  // 1. set 'branch' to col-1 once, no newline\r\n  // 2. for subbranch length, add elm to col-2, then newline\r\n  // 3. after last subbranch elm, newline and set back to col-1\r\n\r\n  // createTree is the moment I loop through tree.json:\r\n  // it is therefore the moment to demarcate key nodes\r\n  // such as first and last subbranches, or perhaps\r\n  // simply demarcate the indexes of all subbranches,\r\n  // into the DOM so that query listener can know about\r\n  // this structure.\r\n\r\n  // or: change branch styling loops to tree.json based rather\r\n  //     than DOM node based(uses filtered [unordered] arrays)\r\n\r\n  // OR: assign a reference to the newly created DOM node to sb[2]?\r\n  // [\"primer_2027\", \"https://par-ity.io, [DOM_REFERENCE]\"]\r\n\r\n  // console.log(document.querySelector(`.c${c}.r${r}`).className);\r\n\r\n-->\r\n<!-- ------------------------------------------------------------- -->\r\n<!-- crazy attempt to handle all possible query-tree matches smh.. -->\r\n<!-- \r\n  // const branchCombos = [];\r\n  // const subbranchCombos = [];\r\n\r\n  // const sbArray = [];\r\n\r\n  // for (const branch in tree) {\r\n  //   if (typeof tree[branch] === \"object\") {\r\n  //     // console.log(branch);\r\n  //     sbArray.push(tree[branch]);\r\n  //   }\r\n  // }\r\n  // console.log(sbArray);\r\n-->\r\n<!-- ------------------------------------------------------------- -->\r\n\r\n<!-- console.log( subbranches[ii].previousElementSibling.previousElementSibling );\r\nthis attempt to stop while looping over aleady visible subbranches just breaks\r\nthe loop when it should run... i think it is targeting the wrong elm... &&\r\nsubbranch.previousElementSibling.previousElementSibling.style .visibility ===\r\n\"hidden\" question.. do i want to stop looping over already lit-up -->\r\n\r\n<!-- // for (let i = 0; i < Object.keys(obj[branch]).length; i++) {\r\n  //   c = 2;\r\n  //   r++;\r\n  //   console.log();\r\n\r\n  //   document.querySelector(`.c${c}.r${r}`).textContent = Object.keys(\r\n  //     obj[branch]\r\n  //   )[i];\r\n  // } -->\r\n\r\n<!-- html/nav structure options -->\r\n<!-- json, array, object, grid, table, list, mermaidjs ? -->\r\n<!-- could generate these grid items by parameterised calls to a component that makes #each html calls -->\r\n\r\n<!-- {#each x as y}{/each} -->\r\n\r\n<!--\r\n  // let branches = Object.keys(tree);\r\n  // console.log(branches);\r\n\r\n  // from https://stackoverflow.com/a/44134784\r\n  // const getObjRows = obj => {\r\n  //   return Object.keys(tree).reduce(function(r, k) {\r\n  //     return r.concat(k, tree[k]);\r\n  //   }, []);\r\n  // };\r\n\r\n  // console.log(\r\n  //   tree.flatMap(a =>\r\n  //     typeof a == \"object\" ? console.log(\"col-2\") : console.log(\"col-1\")\r\n  //   )\r\n  // );\r\n  // console.log(Object.keys(flatten(tree)));\r\n  // console.log(Object.entries(tree));\r\n  // console.log(flatten(tree).length);\r\n\r\n  // const flatTree = flatten(tree);\r\n  // } -->\r\n"
  ],
  "names": [],
  "mappings": "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"
}